//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.1.3
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord, BebopJson, BebopTypeGuard, Guid, GuidMap } from "bebop";
import { Metadata, MethodType } from "@tempojs/common";
import {  BaseClient, MethodInfo, CallOptions } from "@tempojs/client";
import { ServiceRegistry, BaseService, ServerContext, BebopMethodAny, BebopMethod } from "@tempojs/server";

export const BEBOP_SCHEMA = new Uint8Array ([
3, 3, 0, 0, 0, 77, 101, 115, 115, 97, 103, 101, 0, 2, 0,
5, 0, 0, 0, 10, 109, 101, 116, 104, 111, 100, 73, 100, 0,
251, 255, 255, 255, 0, 1, 109, 101, 115, 115, 97, 103,
101, 73, 100, 0, 244, 255, 255, 255, 0, 2, 116, 105, 109,
101, 115, 116, 97, 109, 112, 0, 243, 255, 255, 255, 0, 3,
100, 97, 116, 97, 0, 242, 255, 255, 255, 0, 254, 255, 255,
255, 0, 4, 100, 101, 97, 100, 108, 105, 110, 101, 0, 243,
255, 255, 255, 0, 5, 115, 116, 97, 116, 117, 115, 0, 254,
255, 255, 255, 0, 6, 109, 115, 103, 0, 245, 255, 255, 255,
0, 7, 97, 117, 116, 104, 111, 114, 105, 122, 97, 116, 105,
111, 110, 0, 245, 255, 255, 255, 0, 8, 99, 114, 101, 100,
101, 110, 116, 105, 97, 108, 0, 245, 255, 255, 255, 0, 9,
99, 117, 115, 116, 111, 109, 77, 101, 116, 97, 100, 97,
116, 97, 0, 241, 255, 255, 255, 245, 255, 255, 255, 242,
255, 255, 255, 0, 245, 255, 255, 255, 0, 10, 72, 101, 108,
108, 111, 82, 101, 113, 117, 101, 115, 116, 0, 1, 0, 0, 4,
0, 0, 0, 0, 1, 110, 97, 109, 101, 0, 245, 255, 255, 255,
0, 72, 101, 108, 108, 111, 82, 101, 115, 112, 111, 110,
115, 101, 0, 1, 0, 0, 4, 0, 0, 0, 0, 1, 115, 101, 114,
118, 105, 99, 101, 77, 101, 115, 115, 97, 103, 101, 0,
245, 255, 255, 255, 0, 1, 0, 0, 0, 71, 114, 101, 101, 116,
101, 114, 0, 0, 4, 0, 0, 0, 115, 97, 121, 72, 101, 108,
108, 111, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 85, 246, 254,
77, 115, 97, 121, 72, 101, 108, 108, 111, 67, 108, 105,
101, 110, 116, 0, 0, 2, 1, 0, 0, 0, 2, 0, 0, 0, 196, 25,
111, 204, 115, 97, 121, 72, 101, 108, 108, 111, 83, 101,
114, 118, 101, 114, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 84,
166, 66, 202, 115, 97, 121, 72, 101, 108, 108, 111, 68,
117, 112, 108, 101, 120, 0, 0, 3, 1, 0, 0, 0, 2, 0, 0, 0,
66, 158, 17, 152
]);

export interface IMessage extends BebopRecord {

  methodId?: number;

  messageId?: Guid;

  timestamp?: Date;

  data?: Uint8Array;

  deadline?: Date;

  status?: number;

  msg?: string;

  authorization?: string;

  credential?: string;

  customMetadata?: Map<string, Array<string>>;
}

export class Message implements IMessage {
  public methodId?: number;
  public messageId?: Guid;
  public timestamp?: Date;
  public data?: Uint8Array;
  public deadline?: Date;
  public status?: number;
  public msg?: string;
  public authorization?: string;
  public credential?: string;
  public customMetadata?: Map<string, Array<string>>;

  constructor(record: IMessage) {
    this.methodId = record.methodId;
    this.messageId = record.messageId;
    this.timestamp = record.timestamp;
    this.data = record.data;
    this.deadline = record.deadline;
    this.status = record.status;
    this.msg = record.msg;
    this.authorization = record.authorization;
    this.credential = record.credential;
    this.customMetadata = record.customMetadata;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return Message.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IMessage): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Message.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Message}.
   */
  public static validateCompatibility(record: IMessage): void {
    if (record.methodId !== undefined) {
      BebopTypeGuard.ensureUint32(record.methodId)
    }
    if (record.messageId !== undefined) {
      BebopTypeGuard.ensureGuid(record.messageId)
    }
    if (record.timestamp !== undefined) {
      BebopTypeGuard.ensureDate(record.timestamp)
    }
    if (record.data !== undefined) {
      BebopTypeGuard.ensureArray(record.data, BebopTypeGuard.ensureUint8);
    }
    if (record.deadline !== undefined) {
      BebopTypeGuard.ensureDate(record.deadline)
    }
    if (record.status !== undefined) {
      BebopTypeGuard.ensureUint8(record.status)
    }
    if (record.msg !== undefined) {
      BebopTypeGuard.ensureString(record.msg)
    }
    if (record.authorization !== undefined) {
      BebopTypeGuard.ensureString(record.authorization)
    }
    if (record.credential !== undefined) {
      BebopTypeGuard.ensureString(record.credential)
    }
    if (record.customMetadata !== undefined) {
      BebopTypeGuard.ensureMap(record.customMetadata, BebopTypeGuard.ensureString, (element) => BebopTypeGuard.ensureArray(element, BebopTypeGuard.ensureString));
    }
  }

  /**
   * Unsafely creates an instance of {@link Message} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IMessage {
      return new Message(record);
  }

  /**
   * Creates a new {@link Message} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IMessage {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Message.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Message.validateCompatibility(parsed);
    return Message.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Message.encode(this);
  }

  public static encode(record: IMessage): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Message.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IMessage, view: BebopView): number {
    const before = view.length;
    const pos = view.reserveMessageLength();
    const start = view.length;
    if (record.methodId !== undefined) {
      view.writeByte(1);
      view.writeUint32(record.methodId);
    }
    if (record.messageId !== undefined) {
      view.writeByte(2);
      view.writeGuid(record.messageId);
    }
    if (record.timestamp !== undefined) {
      view.writeByte(3);
      view.writeDate(record.timestamp);
    }
    if (record.data !== undefined) {
      view.writeByte(4);
      view.writeBytes(record.data);
    }
    if (record.deadline !== undefined) {
      view.writeByte(5);
      view.writeDate(record.deadline);
    }
    if (record.status !== undefined) {
      view.writeByte(6);
      view.writeByte(record.status);
    }
    if (record.msg !== undefined) {
      view.writeByte(7);
      view.writeString(record.msg);
    }
    if (record.authorization !== undefined) {
      view.writeByte(8);
      view.writeString(record.authorization);
    }
    if (record.credential !== undefined) {
      view.writeByte(9);
      view.writeString(record.credential);
    }
    if (record.customMetadata !== undefined) {
      view.writeByte(10);
      view.writeUint32(record.customMetadata.size);
    for (const [k0, v0] of record.customMetadata) {
      view.writeString(k0);
      {
        const length1 = v0.length;
        view.writeUint32(length1);
        for (let i1 = 0; i1 < length1; i1++) {
          view.writeString(v0[i1]);
        }
      }
    }
    }
    view.writeByte(0);
    const end = view.length;
    view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IMessage {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Message.readFrom(view);
  }

  public static readFrom(view: BebopView): IMessage {
    let message: IMessage = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return new Message(message);

        case 1:
          message.methodId = view.readUint32();
          break;

        case 2:
          message.messageId = view.readGuid();
          break;

        case 3:
          message.timestamp = view.readDate();
          break;

        case 4:
          message.data = view.readBytes();
          break;

        case 5:
          message.deadline = view.readDate();
          break;

        case 6:
          message.status = view.readByte();
          break;

        case 7:
          message.msg = view.readString();
          break;

        case 8:
          message.authorization = view.readString();
          break;

        case 9:
          message.credential = view.readString();
          break;

        case 10:
          {
        let length0 = view.readUint32();
        message.customMetadata = new Map<string, Array<string>>();
        for (let i0 = 0; i0 < length0; i0++) {
          let k0: string;
          let v0: Array<string>;
          k0 = view.readString();
          {
            let length1 = view.readUint32();
            v0 = new Array<string>(length1);
            for (let i1 = 0; i1 < length1; i1++) {
              let x1: string;
              x1 = view.readString();
              v0[i1] = x1;
            }
          }
          message.customMetadata.set(k0, v0);
        }
      }
          break;

        default:
          view.index = end;
          return new Message(message);
      }
    }
  }
}

/**
 * `HelloRequest` is a struct representing a request to the Greeter service.
 */
export interface IHelloRequest extends BebopRecord {
  /**
   * The name to be used in the greeting, of type string.
   */
  readonly name: string;
}

export class HelloRequest implements IHelloRequest {
  public readonly name: string;

  constructor(record: IHelloRequest) {
    this.name = record.name;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return HelloRequest.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IHelloRequest): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    HelloRequest.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link HelloRequest}.
   */
  public static validateCompatibility(record: IHelloRequest): void {
    BebopTypeGuard.ensureString(record.name)
  }

  /**
   * Unsafely creates an instance of {@link HelloRequest} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IHelloRequest {
      return new HelloRequest(record);
  }

  /**
   * Creates a new {@link HelloRequest} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IHelloRequest {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`HelloRequest.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    HelloRequest.validateCompatibility(parsed);
    return HelloRequest.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return HelloRequest.encode(this);
  }

  public static encode(record: IHelloRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    HelloRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IHelloRequest, view: BebopView): number {
    const before = view.length;
    view.writeString(record.name);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IHelloRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return HelloRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IHelloRequest {
    let field0: string;
    field0 = view.readString();
    let message: IHelloRequest = {
      name: field0,
    };
    return new HelloRequest(message);
  }
}

/**
 * `HelloResponse` is a struct representing the response from the Greeter service.
 */
export interface IHelloResponse extends BebopRecord {
  /**
   * The greeting message generated by the service, of type string.
   */
  readonly serviceMessage: string;
}

export class HelloResponse implements IHelloResponse {
  public readonly serviceMessage: string;

  constructor(record: IHelloResponse) {
    this.serviceMessage = record.serviceMessage;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return HelloResponse.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IHelloResponse): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    HelloResponse.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link HelloResponse}.
   */
  public static validateCompatibility(record: IHelloResponse): void {
    BebopTypeGuard.ensureString(record.serviceMessage)
  }

  /**
   * Unsafely creates an instance of {@link HelloResponse} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IHelloResponse {
      return new HelloResponse(record);
  }

  /**
   * Creates a new {@link HelloResponse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IHelloResponse {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`HelloResponse.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    HelloResponse.validateCompatibility(parsed);
    return HelloResponse.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return HelloResponse.encode(this);
  }

  public static encode(record: IHelloResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    HelloResponse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IHelloResponse, view: BebopView): number {
    const before = view.length;
    view.writeString(record.serviceMessage);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IHelloResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return HelloResponse.readFrom(view);
  }

  public static readFrom(view: BebopView): IHelloResponse {
    let field0: string;
    field0 = view.readString();
    let message: IHelloResponse = {
      serviceMessage: field0,
    };
    return new HelloResponse(message);
  }
}

/**
 * `Greeter` is a service that provides a method for generating greeting messages.
 */
/**
 * `Greeter` is a service that provides a method for generating greeting messages.
 */
export abstract class BaseGreeterService extends BaseService {
  public static readonly serviceName = 'GreeterService';
  /**
   * `sayHello` is a method that takes a `HelloRequest` and returns a `HelloResponse`.
   */
  public abstract sayHello(record: IHelloRequest, context: ServerContext): Promise<IHelloResponse>;
  public abstract sayHelloClient(records: () => AsyncGenerator<IHelloRequest, void, undefined>, context: ServerContext): Promise<IHelloResponse>;
  public abstract sayHelloServer(record: IHelloRequest, context: ServerContext): AsyncGenerator<IHelloResponse, void, undefined>;
  public abstract sayHelloDuplex(records: () => AsyncGenerator<IHelloRequest, void, undefined>, context: ServerContext): AsyncGenerator<IHelloResponse, void, undefined>;
}

export class TempoServiceRegistry extends ServiceRegistry {
  private static readonly staticServiceInstances: Map<string, BaseService> = new Map<string, BaseService>();
  public static register(serviceName: string) {
    return (constructor: Function) => {
      const service = Reflect.construct(constructor, [undefined]);
      if (TempoServiceRegistry.staticServiceInstances.has(serviceName)) {
        throw new Error(`Duplicate service registered: ${serviceName}`);
      }
      TempoServiceRegistry.staticServiceInstances.set(serviceName, service);
    }
  }
  public static tryGetService(serviceName: string): BaseService {
    const service = TempoServiceRegistry.staticServiceInstances.get(serviceName);
    if (service === undefined) {
      throw new Error(`Unable to retreive service '${serviceName}' - it is not registered.`);
    }
    return service;
  }

  public init(): void {
    let service: BaseService;
    let serviceName: string;
    serviceName = 'GreeterService';
    service = TempoServiceRegistry.tryGetService(serviceName);
    if (!(service instanceof BaseGreeterService)) {
      throw new Error(`No service named '${serviceName}'was registered with the TempoServiceRegistry`);
    }
    service.setLogger(this.logger.clone(serviceName));
    TempoServiceRegistry.staticServiceInstances.delete(serviceName);
    this.serviceInstances.push(service);
    if (this.methods.has(1308554837)) {
      const conflictService = this.methods.get(1308554837)!;
      throw new Error(`GreeterService.sayHello collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(1308554837, {
      name: 'sayHello',
      service: serviceName,
      invoke: service.sayHello,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      stringify: HelloResponse.encodeToJSON,
      fromJSON: HelloRequest.fromJSON,
      type: MethodType.Unary,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
    if (this.methods.has(3429833156)) {
      const conflictService = this.methods.get(3429833156)!;
      throw new Error(`GreeterService.sayHelloClient collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(3429833156, {
      name: 'sayHelloClient',
      service: serviceName,
      invoke: service.sayHelloClient,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      stringify: HelloResponse.encodeToJSON,
      fromJSON: HelloRequest.fromJSON,
      type: MethodType.ClientStream,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
    if (this.methods.has(3393365588)) {
      const conflictService = this.methods.get(3393365588)!;
      throw new Error(`GreeterService.sayHelloServer collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(3393365588, {
      name: 'sayHelloServer',
      service: serviceName,
      invoke: service.sayHelloServer,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      stringify: HelloResponse.encodeToJSON,
      fromJSON: HelloRequest.fromJSON,
      type: MethodType.ServerStream,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
    if (this.methods.has(2551291458)) {
      const conflictService = this.methods.get(2551291458)!;
      throw new Error(`GreeterService.sayHelloDuplex collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(2551291458, {
      name: 'sayHelloDuplex',
      service: serviceName,
      invoke: service.sayHelloDuplex,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      stringify: HelloResponse.encodeToJSON,
      fromJSON: HelloRequest.fromJSON,
      type: MethodType.DuplexStream,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
  }

  getMethod(id: number): BebopMethodAny | undefined {
    return this.methods.get(id);
  }
}
/**
 * `Greeter` is a service that provides a method for generating greeting messages.
 */
export interface IGreeterClient {
  /**
   * `sayHello` is a method that takes a `HelloRequest` and returns a `HelloResponse`.
   */
  sayHello(request: IHelloRequest): Promise<IHelloResponse>;
  sayHello(request: IHelloRequest, metadata: Metadata): Promise<IHelloResponse>;

  sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>): Promise<IHelloResponse>;
  sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>, metadata: Metadata): Promise<IHelloResponse>;

  sayHelloServer(request: IHelloRequest): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  sayHelloServer(request: IHelloRequest, metadata: Metadata): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;

  sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>, metadata: Metadata): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
}

/**
 * `Greeter` is a service that provides a method for generating greeting messages.
 */
export class GreeterClient extends BaseClient implements IGreeterClient {
  private static readonly sayHelloMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHello',
    service: 'GreeterService',
    id: 1308554837,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode,
    stringify: HelloRequest.encodeToJSON,
    fromJSON: HelloResponse.fromJSON,
    type: MethodType.Unary,
  }
  /**
   * `sayHello` is a method that takes a `HelloRequest` and returns a `HelloResponse`.
   */
  async sayHello(request: IHelloRequest): Promise<IHelloResponse>;
  async sayHello(request: IHelloRequest, options: CallOptions): Promise<IHelloResponse>;
  async sayHello(request: IHelloRequest, options?: CallOptions): Promise<IHelloResponse> {
    return await this.channel.startUnary(request, this.getContext(), GreeterClient.sayHelloMethodInfo, options);
  }
  private static readonly sayHelloClientMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHelloClient',
    service: 'GreeterService',
    id: 3429833156,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode,
    stringify: HelloRequest.encodeToJSON,
    fromJSON: HelloResponse.fromJSON,
    type: MethodType.ClientStream,
  }

  async sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>): Promise<IHelloResponse>;
  async sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>, options: CallOptions): Promise<IHelloResponse>;
  async sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>, options?: CallOptions): Promise<IHelloResponse> {
    return await this.channel.startClientStream(request, this.getContext(), GreeterClient.sayHelloClientMethodInfo, options);
  }
  private static readonly sayHelloServerMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHelloServer',
    service: 'GreeterService',
    id: 3393365588,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode,
    stringify: HelloRequest.encodeToJSON,
    fromJSON: HelloResponse.fromJSON,
    type: MethodType.ServerStream,
  }

  async sayHelloServer(request: IHelloRequest): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  async sayHelloServer(request: IHelloRequest, options: CallOptions): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  async sayHelloServer(request: IHelloRequest, options?: CallOptions): Promise<AsyncGenerator<IHelloResponse, void, undefined>> {
    return await this.channel.startServerStream(request, this.getContext(), GreeterClient.sayHelloServerMethodInfo, options);
  }
  private static readonly sayHelloDuplexMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHelloDuplex',
    service: 'GreeterService',
    id: 2551291458,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode,
    stringify: HelloRequest.encodeToJSON,
    fromJSON: HelloResponse.fromJSON,
    type: MethodType.DuplexStream,
  }

  async sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  async sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>, options: CallOptions): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  async sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>, options?: CallOptions): Promise<AsyncGenerator<IHelloResponse, void, undefined>> {
    return await this.channel.startDuplexStream(request, this.getContext(), GreeterClient.sayHelloDuplexMethodInfo, options);
  }
}
